<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

  <meta name="author" content="Patrick D. Elliott">



  <title>Introduction to Dynamic Semantics</title>
  <style type="text/css">code{white-space: pre;}</style>


  <link rel="stylesheet" href="./css/tufte.css" />
  <link rel="stylesheet" href="./css/pandoc.css" />
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML" async>
  </script>

  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<article>

<header>
<h1 class="title">Introduction to Dynamic Semantics</h1>

<p class="subtitle">Lecture 1</p>


<p class="byline">25.06.2018 &ndash; Patrick D. Elliott</p>

</header>


<p><span class="math display">\[
\newcommand{\eval}[2][]{{\left[\!\!\left[\text{#2}\right]\!\!\right]^{#1}}}
\newcommand{\evalM}[2][]{{\left[\!\!\left[ #2 \right]\!\!\right]^{#1}}}
\newcommand{\Set}[1]{\left\lbrace #1 \right\rbrace}
\newcommand{\lam}[1]{{\lambda #1\,.\,}}
\newcommand{\type}[1]{{\mathtt{#1}}}
\newcommand{\metalang}[1]{{\textbf{#1}}}
\newcommand{\entity}[1]{{\texttt{#1}}}
\]</span></p>
<section id="lecture-1-the-formal-semanticists-toolkit" class="level1">
<h1>Lecture 1: The Formal Semanticist’s Toolkit</h1>
<section id="slides" class="level2">
<h2>Slides</h2>
<ul>
<li>pdf: <a href="https://patrl.keybase.pub/actl2018/lecture1.pdf" class="uri">https://patrl.keybase.pub/actl2018/lecture1.pdf</a></li>
<li>html (support here still sketchy!): <a href="https://patrickdelliott.com/actl2018notes.html" class="uri">https://patrickdelliott.com/actl2018notes.html</a></li>
</ul>
</section>
<section id="roadmap" class="level2">
<h2>Roadmap</h2>
<ul>
<li><p>An overview of what semanticists are interested in.</p></li>
<li><p>A lightning-fast overview of some basic formal machinery: sets, functions, and lambdas.</p></li>
<li><p>Constructing our first formal language L<sub>1</sub>.</p></li>
<li><p><em>First Order Logic</em> (FOL)</p></li>
<li><p>Next week: <em>Dynamic Predicate Logic</em> (DPL)</p></li>
</ul>
</section>
<section id="formal-semantics" class="level2">
<h2>Formal semantics</h2>
<ul>
<li><p>This class is going to provide you with an introduction to <em>formal semantics</em>.</p></li>
<li>What formal semantics is <em>not</em>:
<ul>
<li>A theory of the connotations and cultural associations of particular words and phrases.</li>
<li>A theory of how we communicate through language.</li>
<li>A theory of concepts, and how we acquire them.</li>
</ul></li>
<li><p>Rather formal semantics is typically concerned with the <em>logical</em> (i.e. <em>formal</em>) properties of language. Arguably, a theory of formal semantics should inform all of the above.</p></li>
</ul>
</section>
<section id="formal-semantics-ii" class="level2">
<h2>Formal semantics ii</h2>
<ul>
<li><p>But…why isn’t this class called <em>Introduction to Formal Semantics</em>?</p></li>
<li><p>The particular perspective we’re going to work towards is that of <em>dynamic semantics</em>, a family of theories developed in the eighties and nineties by Irene Heim, Hans Kamp, Jeroen Groenendijk, Martin Stokhof, Paul Dekker, and others.</p></li>
</ul>
</section>
<section id="dynamic-semantics" class="level2">
<h2>Dynamic Semantics</h2>
<ul>
<li><p>Dynamic semantics is an approach to formal semantics which provides a unified perspective on anaphora, quantification, and the flow of discourse.</p></li>
<li><p>In the first part of the class, we’re going to work towards an analysis of <em>donkey anaphora</em>, illustrated by the famous example sentence in (1), using Groenendijk and Stokhof’s theory <em>Dynamic Predicate Logic</em>.</p>
<ol class="example" type="1">
<li>every farmer who owns a donkey<span class="math inline">\(^x\)</span> hits it<span class="math inline">\(_x\)</span></li>
</ol></li>
</ul>
</section>
<section id="dynamic-semantics-ii" class="level2">
<h2>Dynamic semantics ii</h2>
<ul>
<li><p>In most introductory classes, what is taught is a strictly <em>static</em> semantics, where the unit of analysis is strictly the <em>sentence</em>.</p></li>
<li><p>One of the key insights of dynamic semantics is that, not just sentences, but <em>discourses</em> can be assigned truth-conditions.</p>
<ol start="2" class="example" type="1">
<li>A man<span class="math inline">\(^x\)</span> walked in the room. He<span class="math inline">\(_x\)</span> sat down.</li>
</ol></li>
<li><ol start="3" class="example" type="1">
<li>is true iff there is a man <span class="math inline">\(x\)</span>, s.t. <span class="math inline">\(x\)</span> walked in the room and <span class="math inline">\(x\)</span>.</li>
</ol></li>
</ul>
</section>
<section id="dynamic-semantics-iii" class="level2">
<h2>Dynamic semantics iii</h2>
<ul>
<li><p>One thing we’re going to be thinking through is the relationship between a static semantics a dynamic semantics.</p></li>
<li><p>In today’s class, we’re going to work towards a formal, static semantics of English, using First Order Logic as our tool.</p></li>
<li><p>But first, some broad perspectives on the study of meaning in natural language.</p></li>
</ul>
</section>
<section id="in-the-beginning-there-was-syntax" class="level2">
<h2>In the beginning, there was syntax</h2>
<ul>
<li>It’s all about this guy:</li>
</ul>
<figure>
<img src="images/chomsky.jpg" alt="Noam Chomsky (right)" style="width:50.0%" /><figcaption>Noam Chomsky (right)</figcaption>
</figure>
</section>
<section id="in-the-beginning-there-was-syntax-ii" class="level2">
<h2>In the beginning, there was syntax ii</h2>
<ul>
<li><p>(Generative) syntax, when you really get down to it, is the study of an individual language (or idiolect) <span class="math inline">\(L\)</span>. A “language”, such as English, is just a useful abstraction over a set of sufficiently similar <span class="math inline">\(L\)</span>s.</p></li>
<li><p>The question syntacticians ask themselves is: how can we specify what the possible sentences of <span class="math inline">\(L\)</span> are?</p></li>
</ul>
</section>
<section id="syntactic-methodology" class="level2">
<h2>Syntactic methodology</h2>
<ul>
<li><p>Typically, syntacticians do this by giving a <em>grammar</em> of <span class="math inline">\(L\)</span>.</p></li>
<li><p>Depending on your theory, a grammar can be a set of rewrite rules, a recursive procedure for building structured representations, or a combinary logic. It amounts to more-or-less the same thing at the end of day.</p></li>
<li><p>A grammar of <span class="math inline">\(L\)</span> is taken to be an abstract description of What We Know When We Know <span class="math inline">\(L\)</span>.</p></li>
</ul>
</section>
<section id="an-aside" class="level2">
<h2>An aside</h2>
<ul>
<li>Some (generative) theories of syntax:
<ul>
<li>Lexical Functional Grammar, Combinary Categorial Grammar, Minimalism, …</li>
</ul></li>
<li><p>I’m going to try to stay as neutral as possible about which flavour of syntax tastes the best.</p></li>
<li><p>When I <em>have</em> to say something about syntax, I’m going to assume a simplified version of Chomsky’s Government and Binding theory, since it’s the one that most people seem to have been exposed to.</p></li>
<li><p>I’m happy to argue about, e.g., construction grammar, in the pub…not so much in class.</p></li>
</ul>
</section>
<section id="syntactic-intuitions-ii" class="level2">
<h2>Syntactic intuitions ii</h2>
<ul>
<li>How do we know what a possible sentence of <span class="math inline">\(L\)</span> is?
<ul>
<li>If we’re a native speaker of <span class="math inline">\(L\)</span>, we can consult our own intuitions about the acceptability of a given sentence.</li>
<li>We can consult a native speaker of <span class="math inline">\(L\)</span>.</li>
</ul></li>
<li>The vast majority of the raw data syntacticians deal with is <em>speaker acceptability judgements</em>, be they collected informally or experimentally.</li>
</ul>
</section>
<section id="meaning-as-truth-conditions" class="level2">
<h2>Meaning as truth-conditions</h2>
<ul>
<li>To know the meaning of a sentence is to know its <em>truth conditions</em>.</li>
</ul>
<figure>
<img src="images/tarski.jpg" alt="Polish mathematician and Logician Alfred Tarski (src: the Oberwolfach photo collection)" style="width:50.0%" /><figcaption>Polish mathematician and Logician Alfred Tarski<br />
(src: the Oberwolfach photo collection)</figcaption>
</figure>
</section>
<section id="meaning-as-truth-conditions-1" class="level2">
<h2>Meaning as truth-conditions</h2>
<ol start="4" class="example" type="1">
<li>Russians penetrated U.S. voter systems.</li>
</ol>
<ul>
<li><p>We don’t need to know whether or not (4) is <em>true</em> to know what it <em>means</em>.</p></li>
<li><p>What we do know (roughly), is how the world would have to be for (4) to be true – (4) is <em>true</em> if Russians penetrated U.S. voter systems, and <em>false</em> otherwise.</p></li>
<li><p>Is this just stating the obvious?</p></li>
</ul>
</section>
<section id="semantic-intuitions" class="level2">
<h2>Semantic intuitions</h2>
<ul>
<li><p>Let’s say we’re studying the semantics of a given language <span class="math inline">\(L\)</span>, and we have the syntax of <span class="math inline">\(L\)</span> pretty well-worked out.</p></li>
<li><p>Our task as semanticists is to specify a recursive procedure for mapping sentences of <span class="math inline">\(L\)</span> to <em>meanings</em>.</p></li>
<li><p>How do we know what a given sentence of <span class="math inline">\(L\)</span> means? Just as before, we have to rely on native speaker intuitions.</p></li>
</ul>
</section>
<section id="truth-conditions" class="level2">
<h2>Truth conditions</h2>
<ul>
<li><p>But, we can’t just ask our native speaker, what does “snow is white” <em>mean</em>? We’re bound to get a vague or unhelpful answer. Try this out yourselves (if you want to annoy your friends).</p></li>
<li><p>Instead, we can ask our native speaker, if in a given situation, a sentence of <span class="math inline">\(L\)</span> is <em>true</em>, and through asking these questions, we can infer the sentences truth-conditions.</p>
<ol start="5" class="example" type="1">
<li>If snow is black, is “snow is white” true?</li>
</ol></li>
</ul>
</section>
<section id="truth-conditions-ii" class="level2">
<h2>Truth conditions ii</h2>
<ul>
<li>In many situations, the results seem bleedingly obvious, but it very quickly gets more interesting (and complicated).</li>
</ul>
<ol start="6" class="example" type="1">
<li>At least one person from every country has eaten most of its national dishes.</li>
</ol>
<ul>
<li><p>Semantics then, involves developing a recursive procedure for mapping sentences of <span class="math inline">\(L\)</span> to their <em>truth-conditions</em>.</p></li>
<li><p>One of the reasons why the Tarskian conjecture doesn’t seem so interesting at first sight, is that the language that we’re using to describe truth-conditions is <em>English</em>.</p></li>
</ul>
</section>
<section id="the-meta--and-object--language" class="level2">
<h2>The meta- and object- language</h2>
<ul>
<li><p>We call the language we use to specify the truth-conditions of a given sentence our <em>metalanguage</em>.</p></li>
<li><p>We call the language we’re interested in interpreting - in this case English - the <em>object language</em>.</p></li>
<li><p>When the metalanguage and object language are the same, statements of truth-conditions have the feeling of circularity.</p></li>
<li><p>What we need, if we’re going to develop a satisfactory semantic theory, is a completely unambiguous metalanguage, the meaning of which we can state in a completely rigorous way…what we need, if a <em>formal</em> language.</p></li>
</ul>
</section>
<section id="natural-language-as-a-formal-language" class="level2">
<h2>Natural language as a formal language</h2>
<blockquote>
<p>I reject the contention that an important theoretical difference exists between formal and natural languages’ (Montague, 1970)</p>
</blockquote>
<figure>
<img src="images/montague.jpg" alt="the philosopher Richard Montague (1930-1971)" style="width:30.0%" /><figcaption>the philosopher Richard Montague (1930-1971)</figcaption>
</figure>
</section>
<section id="interpretation-as-a-process" class="level2">
<h2>Interpretation as a <em>process</em></h2>
<ul>
<li>The <em>dynamic turn</em> in formal semantics: meaning doesn’t lie in <em>truth conditions</em>, but rather in how a given sentence changes the beliefs of the participants (Stalnaker, Heim, Kamp, Groenendijk and Stokhof, etc.).</li>
</ul>
<figure>
<img src="images/stalnaker.jpg" alt="the philosopher Robert Stalnaker" style="width:50.0%" /><figcaption>the philosopher Robert Stalnaker</figcaption>
</figure>
</section>
<section id="the-semantics-of-programming-languages" class="level2">
<h2>the semantics of programming languages</h2>
<ul>
<li><p>The perspective on semantics we’ll be working towards has important connections with the semantics of <em>programming languages</em> (here we circle back to the Montagovian program).</p></li>
<li><p>In computer science, the <em>meaning</em> of a program is how it affects an abstract machine <em>state</em>. The <em>state</em> can be, e.g., the allocation of values to locations in memory.</p></li>
<li><p>The meaning of a program, therefore, can be thought of as an <em>instruction for changing the current state</em>.</p></li>
<li><p>We’ll see examples of this in the next session.</p></li>
</ul>
</section>
<section id="reference" class="level2">
<h2>Reference</h2>
<ul>
<li><p>See <a href="http://eecoppock.info/DynamicSemantics/Lectures/logic-2up.pdf">Elizabeth Coppock’s primer</a>.</p></li>
<li><p><a href="http://eecoppock.info/DynamicSemantics/Lectures/logic-2up.pdf" class="uri">http://eecoppock.info/DynamicSemantics/Lectures/logic-2up.pdf</a></p></li>
<li><p>If I go too fast for you today, please go back and work through this. The majority of what I’ll go through is there, in a condensed format.</p></li>
</ul>
</section>
</section>
<section id="some-background-lightning-fast" class="level1">
<h1>Some background, lightning fast</h1>
<section id="truth-tables-for-propositional-logic-and" class="level2">
<h2>Truth-tables for propositional logic – <em>and</em></h2>
<ul>
<li><em>and</em> (<span class="math inline">\(∧\)</span>)</li>
</ul>
<p><span class="math display">\[
\begin{aligned}[t]
&amp;P &amp;Q &amp; &amp;P ∧ Q\\
&amp;1 &amp;1 &amp; &amp;1\\
&amp;1 &amp;0 &amp; &amp;0\\
&amp;0 &amp;1 &amp; &amp;0\\
&amp;0 &amp;0 &amp; &amp;0
\end{aligned}
\]</span></p>
</section>
<section id="or" class="level2">
<h2><em>or</em></h2>
<ul>
<li><em>or (inclusive disjunction)</em> (<span class="math inline">\(∨\)</span>)</li>
</ul>
<p><span class="math display">\[
\begin{aligned}[t]
&amp;P &amp;Q &amp; &amp;P ∨ Q\\
&amp;1 &amp;1 &amp; &amp;1\\
&amp;1 &amp;0 &amp; &amp;1\\
&amp;0 &amp;1 &amp; &amp;1\\
&amp;0 &amp;0 &amp; &amp;0
\end{aligned}
\]</span></p>
</section>
<section id="ifthen" class="level2">
<h2><em>if…then…</em></h2>
<ul>
<li><em>if then (material implication)</em> (<span class="math inline">\(→\)</span>)</li>
</ul>
<p><span class="math display">\[
\begin{aligned}[t]
&amp;P &amp;Q &amp; &amp;P → Q\\
&amp;1 &amp;1 &amp; &amp;1\\
&amp;1 &amp;0 &amp; &amp;0\\
&amp;0 &amp;1 &amp; &amp;1\\
&amp;0 &amp;0 &amp; &amp;1
\end{aligned}
\]</span></p>
</section>
<section id="if-and-only-if" class="level2">
<h2><em>if and only if</em></h2>
<ul>
<li><em>iff (biconditional)</em> (<span class="math inline">\(↔\)</span>)</li>
</ul>
<p><span class="math display">\[
\begin{aligned}[t]
&amp;P &amp;Q &amp; &amp;P ↔ Q\\
&amp;1 &amp;1 &amp; &amp;1\\
&amp;1 &amp;0 &amp; &amp;0\\
&amp;0 &amp;1 &amp; &amp;0\\
&amp;0 &amp;0 &amp; &amp;1
\end{aligned}
\]</span></p>
</section>
<section id="set-theory" class="level2">
<h2>Set theory</h2>
<p>This is a set:</p>
<p><span class="math display">\[
\Set{2,4,6}
\]</span></p>
<p>This is a set:</p>
<p><span class="math display">\[
\Set{x | x\text{ is a positive even integer less than }7}
\]</span></p>
<p>These are in fact…the same set.</p>
</section>
<section id="the-empty-set" class="level2">
<h2>The empty set</h2>
<ul>
<li>This is a set:</li>
</ul>
<p><span class="math display">\[
\Set{}
\]</span></p>
<ul>
<li><p>Another way of writing this set is: <span class="math inline">\(\emptyset\)</span>.</p></li>
<li><p>There’s only ONE <span class="math inline">\(\emptyset\)</span>!!! These are all identical to <span class="math inline">\(\emptyset\)</span>:</p></li>
</ul>
<p><span class="math display">\[
\begin{aligned}[t]
&amp;\Set{x | x\text{ is a married bachelor}}\\
&amp;\Set{x | x\text{ is an even prime number and }x\text{ is not }2}\\
&amp;\Set{x | x\text{ is a reasonably priced flat in Bloomsbury}}
\end{aligned}
\]</span></p>
</section>
<section id="relations-on-sets" class="level2">
<h2>Relations on sets</h2>
<ul>
<li><p><span class="math inline">\(A ⊆ B\)</span> – <span class="math inline">\(A\)</span> is a  of <span class="math inline">\(B\)</span> iff every member of <span class="math inline">\(A\)</span> is a member of <span class="math inline">\(B\)</span>. this means that <span class="math inline">\(∅\)</span> is a subset of every set (including itself!)</p></li>
<li><p><span class="math inline">\(A ⊂ B\)</span> – <span class="math inline">\(A\)</span> is a  of <span class="math inline">\(B\)</span> iff <span class="math inline">\(A ⊆ B\)</span> but <span class="math inline">\(A ≠ B\)</span>.</p></li>
<li><p><span class="math inline">\(A ∪ B\)</span> – the  of <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> is the set of all <span class="math inline">\(x\)</span> s.t. <span class="math inline">\(x ∈ A\)</span> or <span class="math inline">\(x ∈ B\)</span>.</p></li>
<li><p><span class="math inline">\(A ∩ B\)</span> – the  of <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> is the set of all <span class="math inline">\(x\)</span> in both <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span>.</p></li>
<li><p><span class="math inline">\(A − B\)</span> – the  of <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> is the set of <span class="math inline">\(x\)</span>, s.t. <span class="math inline">\(x ∈ A\)</span> but <span class="math inline">\(x ∉ B\)</span>.</p></li>
</ul>
</section>
<section id="ordered-pairs" class="level2">
<h2>Ordered pairs</h2>
<ul>
<li><p><span class="math inline">\(⟨\metalang{Jeff},\metalang{Britta}⟩\)</span> is the ordered pair of <span class="math inline">\(\metalang{Jeff}\)</span> and <span class="math inline">\(\metalang{Britta}\)</span>.</p></li>
<li><p>unlike sets, ordered pairs are order-sensitive:</p>
<p><span class="math inline">\(⟨\metalang{Jeff},\metalang{Britta}⟩ ≠ ⟨\metalang{Jeff},\metalang{Britta}⟩\)</span></p></li>
<li><p>ordered pairs are objects just like anything else, so we can gather them up in sets.</p>
<p><span class="math display">\[
\Set{⟨x,y⟩| x\text{ hugs }y}
\]</span></p></li>
</ul>
</section>
<section id="functions" class="level2">
<h2>Functions</h2>
<ul>
<li><p>A function is something that takes an <em>input</em>, and returns a unique <em>output</em>.</p></li>
<li><p>For example the operation <span class="math inline">\(f\)</span>, which takes an integer and adds <span class="math inline">\(1\)</span> to it. Here are some different ways of writing this function:</p>
<p><span class="math display">\[f(x) = x + 1\]</span></p>
<p><span class="math display">\[
\left[\begin{aligned}[c]
&amp;0 \rightarrow 1\\
&amp;1 \rightarrow 2\\
&amp;3 \rightarrow 4\\
&amp;...
\end{aligned}\right]
\]</span></p></li>
</ul>
</section>
<section id="graphs-of-functions" class="level2">
<h2>Graphs of functions</h2>
<ul>
<li><p><span class="math inline">\(f\)</span> can also be represented as a <em>set of ordered pairs</em>, where the first member of the pair is the input, and the second is the output. This is called the <em>graph</em> of the function.</p>
<p><span class="math display">\[\Set{..., ⟨0,1⟩,⟨1,2⟩,⟨3,4⟩,...}\]</span></p>
<p><span class="math display">\[\Set{⟨x,y⟩|x\text{ is an integer and }y = x + 1}\]</span></p></li>
</ul>
</section>
<section id="anonymous-functions-with-lambdas" class="level2">
<h2>Anonymous functions with lambdas</h2>
<ul>
<li><p>When we wrote the function <span class="math inline">\(f\)</span>, we had to give it a name…<span class="math inline">\(f\)</span>.</p></li>
<li><p>There’s another way to write <span class="math inline">\(f\)</span> without naming it, using a <em>lambda expression</em>.</p></li>
</ul>
<p><span class="math display">\[λ x . x + 1\]</span></p>
<ul>
<li><p>A lambda expression consists of a <em>head</em> (the bit before the dot), and the <em>body</em> (the bit after the dot).</p></li>
<li><p>The function head consists of a <span class="math inline">\(λ\)</span> and an accompanying variable, which tells us where the argument slots into the function body.</p></li>
<li><p>The function body tells us what to do with our argument.</p></li>
</ul>
</section>
<section id="application" class="level2">
<h2>Application</h2>
<ul>
<li>We <em>apply</em> lambda expressions to values like so:</li>
</ul>
<p><span class="math display">\[
[λ x . x + 1](4)
\]</span></p>
<ul>
<li><p>When we apply a lambda expression to an argument, we delete the function head, and substitute all matching occurrences of the variable with the argument, so:</p>
<p><span class="math display">\[
 \begin{aligned}[t]
 &amp;̱= 4 + 1\\
 &amp;= 5
 \end{aligned}
\]</span></p></li>
</ul>
</section>
<section id="nested-lambda-expressions" class="level2">
<h2>Nested lambda expressions</h2>
<ul>
<li>What if we have a function <span class="math inline">\(\textit{subtract}\)</span> that takes two arguments?</li>
</ul>
<p><span class="math display">\[\textit{subtract}(x,y) = y - x\]</span></p>
<ul>
<li>We can write this as a <em>curried</em> (nested) lambda expression, like so:</li>
</ul>
<p><span class="math display">\[
λx . λ y . y - x
\]</span></p>
</section>
<section id="nested-lambda-expressions-ii" class="level2">
<h2>Nested lambda expressions ii</h2>
<ul>
<li>Application is left-associative:</li>
</ul>
<p><span class="math display">\[
\begin{aligned}[t]
&amp;[λ x . λ y . y - x](4)(5)\\
&amp;= [λ y . y - 4](5)\\
&amp;= 5 - 4\\
&amp;= 1
\end{aligned}
\]</span></p>
<ul>
<li><p>Note that out the output of applying our function to <span class="math inline">\(4\)</span> is <em>itself</em> a function: <span class="math inline">\(λ y . y - 4\)</span>.</p></li>
<li><p>Lambda expressions come from the <em>lambda calculus</em> – a formal system for expressing computation. It’s something of a lingua franca in formal semantics, but it’s a big topic, and I’ll try to avoid using it in this class.</p></li>
</ul>
</section>
</section>
<section id="our-first-formal-language-l1" class="level1">
<h1>Our first formal language: L<sub>1</sub></h1>
<section id="first-order-logic-without-variables" class="level2">
<h2>First-order logic without variables</h2>
<ul>
<li><p>We’ll define a language for dealing with things like verbs and proper names. Let’s call it L<sub>1</sub>.</p></li>
<li><p>We’ll be able to use this language for specifying the truth-conditions of sentences like the following:</p>
<ol start="7" class="example" type="1">
<li><p>If Jeff is annoying, then Britta and Annie are bored.<br />
<span class="math inline">\((\metalang{annoying}(J)) → ((\metalang{bored}(B) ∧ \metalang{bored}(A)))\)</span></p></li>
<li><p>Troy likes Abed and not Pierce.<br />
<span class="math inline">\(\metalang{likes}(T,A) ∧ ¬\metalang{likes}(T,P)\)</span></p></li>
</ol></li>
<li><p>Don’t worry about how to interpret these logical translations just yet. We’ll get onto that in a sec.</p></li>
</ul>
</section>
<section id="logical-form" class="level2">
<h2>Logical Form</h2>
<ul>
<li>The logical translation (and hence disambiguation) of natural language sentences corresponds to philosophers’ notion of <em>Logical Form</em>.</li>
</ul>
<figure>
<img src="images/russell.jpg" alt="the philosopher Bertrand Russell (1872-1970)" style="width:50.0%" /><figcaption>the philosopher Bertrand Russell (1872-1970)</figcaption>
</figure>
<ul>
<li>This is an important idea philosophically, as the inferential properties of a sentence can be read directly off of its Logical Form.</li>
</ul>
</section>
<section id="describing-a-formal-language" class="level2">
<h2>Describing a formal language</h2>
<ul>
<li><p>Just like Montague said, the tasks of describing a formal language like L<sub>1</sub> and a natural language like English are really quite similar.</p></li>
<li><p>Just like English, L<sub>1</sub> has a <em>vocabulary</em>, which is exactly what it sounds like.</p></li>
<li><p>Just like English, L<sub>1</sub> has a <em>syntax</em> – this will consist of a set of rules for constructing grammatical sentences of L<sub>1</sub>, which, following the parlance of logicians, we’ll call <em>well-formed formulae</em> (wff) of L<sub>1</sub>.</p></li>
<li><p>Because L<sub>1</sub> abstracts away from many of the complexities of English, including ambiguity, we’ll also be able to give a <em>semantics</em> for L<sub>1</sub>, which will consist of a procedure for computing the truth-conditions of any given wff.</p></li>
</ul>
</section>
<section id="vocabulary-of-l1" class="level2">
<h2>Vocabulary of L<sub>1</sub></h2>
<ol type="1">
<li><p>Individuals contstants/terms: <span class="math inline">\(\textsf{Troy}\)</span>, <span class="math inline">\(\textsf{Annie}\)</span>, <span class="math inline">\(\textsf{Britta}\)</span>, etc</p>
<p>These correspond to <em>proper names</em> and <em>definite descriptions</em> in English.</p></li>
<li><p>Unary predicates: <span class="math inline">\(\textsf{happy}\)</span>, <span class="math inline">\(\textsf{bored}\)</span>, etc</p>
<p>These correspond to <em>adjectives</em> and <em>intransitive verbs</em> in English.</p></li>
<li><p>Binary predicates: <span class="math inline">\(\textsf{kissed}\)</span>, <span class="math inline">\(\textsf{loves}\)</span></p>
<p>These correspond to <em>transitive verbs</em> in English.</p></li>
</ol>
</section>
<section id="syntax-of-l1" class="level2">
<h2>Syntax of L<sub>1</sub></h2>
<ol type="1">
<li><p>If <span class="math inline">\(π\)</span> is a unary predicate and <span class="math inline">\(α\)</span> is a term, then <span class="math inline">\(π(α)\)</span> is a formula.</p></li>
<li><p>If <span class="math inline">\(π\)</span> is a binary predicate and α and β are terms, then <span class="math inline">\(π(α,β)\)</span> is a formula.</p></li>
<li><p>If <span class="math inline">\(ϕ\)</span> is a formula, then <span class="math inline">\(¬ϕ\)</span> is a formula.</p></li>
<li><p>If <span class="math inline">\(ϕ\)</span> and <span class="math inline">\(ψ\)</span> are formulas, then <span class="math inline">\([ϕ ∧ ψ]\)</span> is a formula.</p></li>
<li><p>If <span class="math inline">\(ϕ\)</span> and <span class="math inline">\(ψ\)</span> are formulas, then <span class="math inline">\([ϕ ∨ ψ]\)</span> is a formula.</p></li>
<li><p>If <span class="math inline">\(ϕ\)</span> and <span class="math inline">\(ψ\)</span> are formulas, then <span class="math inline">\([ϕ → ψ]\)</span> is a formula.</p></li>
<li><p>If <span class="math inline">\(ϕ\)</span> and ψ$ are formulas, then <span class="math inline">\([ϕ ↔ ψ]\)</span> is a formula.</p></li>
</ol>
</section>
<section id="an-aside-on-recursion" class="level2">
<h2>An aside on recursion</h2>
<figure>
<img src="images/recursion.jpg" alt="Morris Halle (1923-2018) and Noam Chomsky (src: Kai von Fintel)" style="width:50.0%" /><figcaption>Morris Halle (1923-2018) and Noam Chomsky (src: Kai von Fintel)</figcaption>
</figure>
</section>
<section id="recursion-ii" class="level2">
<h2>recursion ii</h2>
<blockquote>
<p>For example, the most elementary property of the language faculty is the property of discrete infinity; you have six-word sentences, seven-word sentences but you don’t have six-and-a-half-word sentences. Furthermore, there is no limit; you can have ten-word sentences, twenty-word sentences and so on indefinitely. That is the property of discrete infinity. (Chomsky, 2000 – <em>The Architecture of Language</em>)</p>
</blockquote>
</section>
<section id="chomskyan-rewrite-rules" class="level2">
<h2>Chomskyan rewrite rules</h2>
<ul>
<li>Task: use the following set of rewrite rules to generate some sentences. Convince yourself that there is no limit to the number of sentences you can generate.</li>
</ul>
<p><span class="math display">\[
\begin{aligned}[&amp;]
&amp;\text{V} → \text{hugs}\,|\,\text{kisses}\\
&amp;\text{V'} → \text{say} | \text{believe}\\
&amp;\text{NP} → \text{Britta} | \text{Annie}\\
&amp;\text{VP} → \text{V} \text{NP}\\
&amp;\text{VP} → \text{V'} \text{S}\\
&amp;\text{S} → \text{NP} \text{VP}
\end{aligned}
\]</span></p>
<ul>
<li>What is the crucial component here that is responsible for your ability to generate an unlimited number of different sentences?</li>
</ul>
</section>
<section id="an-even-simpler-instance-of-recursion" class="level2">
<h2>An even simpler instance of recursion</h2>
<p><span class="math display">\[
\begin{aligned}[t]
&amp;\text{S} → \text{S and S}\\
&amp;\text{S} → \text{S or S}\\
&amp;\text{S} → \text{if S then S}
&amp;\end{aligned}
\]</span></p>
<ul>
<li>Does this look familiar?</li>
</ul>
</section>
<section id="discrete-infinity" class="level2">
<h2>Discrete infinity</h2>
<ul>
<li>our specification of the syntax of L<sub>1</sub> is <em>recursive</em>, just like Chomsky’s rewrite rules!</li>
</ul>
<ol start="4" type="1">
<li><p>If <span class="math inline">\(ϕ\)</span> and <span class="math inline">\(ψ\)</span> are , then <span class="math inline">\([ϕ ∧ ψ]\)</span> is a .</p></li>
<li><p>If <span class="math inline">\(ϕ\)</span> and <span class="math inline">\(ψ\)</span> are , then <span class="math inline">\([ϕ ∨ ψ]\)</span> is a .</p></li>
<li><p>If <span class="math inline">\(ϕ\)</span> and <span class="math inline">\(ψ\)</span> are , then <span class="math inline">\([ϕ → ψ]\)</span> is a .</p></li>
</ol>
<ul>
<li>If we’re gonna have <em>any</em> hope of analysing the meaning of a natural language using a <em>formal language</em> such as L<sub>1</sub>, we better hope that our formal language is capable of matching natural language’s capacity for discrete infinity.</li>
</ul>
</section>
<section id="questions-on-syntax-of-l1" class="level2">
<h2>Questions on syntax of L<sub>1</sub></h2>
<ul>
<li>Given a suitable vocabulary, which of the following are formulae of L<sub>1</sub>?</li>
</ul>
<ol type="1">
<li><p><span class="math inline">\(¬¬\metalang{happy}(M)\)</span></p></li>
<li><p><span class="math inline">\(\metalang{happy}(A)\)</span></p></li>
<li><p><span class="math inline">\(\metalang{happy}(M,J)\)</span></p></li>
<li><p><span class="math inline">\(\metalang{loves}(J,M) ∨ \metalang{loves}(M,M)\)</span></p></li>
<li><p><span class="math inline">\([\metalang{loves}(J,M) ↔ \metalang{loves}(M,J)]\)</span></p></li>
<li><p><span class="math inline">\([\metalang{kissed}(M) ↔ \metalang{loves}(M,J)]\)</span></p></li>
<li><p><span class="math inline">\(¬[\metalang{loves}(J,M) ← ¬\metalang{loves}(M,J)]\)</span></p></li>
</ol>
</section>
<section id="semantics" class="level2">
<h2>Semantics</h2>
<ul>
<li>The semantics for L<sub>1</sub> is given in terms of a <em>model</em>, i.e., a mathematical description of a toy universe.</li>
</ul>
<figure>
<img src="images/orrery.jpg" alt="src: A Philosopher Lecturing on the Orrery, Joseph Wright of Derby" /><figcaption>src: <em>A Philosopher Lecturing on the Orrery</em>, Joseph Wright of Derby</figcaption>
</figure>
</section>
<section id="semantics-ii" class="level2">
<h2>Semantics ii</h2>
<p><span class="math display">\[
M = ⟨D, I⟩
\]</span></p>
<ul>
<li><p><span class="math inline">\(D\)</span> is the <em>domain</em> of all individuals in <span class="math inline">\(M\)</span>.</p></li>
<li><p><span class="math inline">\(I\)</span> is the <em>interpretation function</em>; it tells us what the vocabulary of L<sub>1</sub> means in <span class="math inline">\(M\)</span>.</p>
<ul>
<li>our mathematical description of the toy universe therefore, tells us who and what exists, and what the expressions in the vocabulary of the language we’re interested in pick out.</li>
</ul></li>
</ul>
</section>
<section id="semantics-iii" class="level2">
<h2>Semantics iii</h2>
<ul>
<li><p>The interpretation of an <em>individual constant</em>, which you can think of as a proper name, will be an individual in the domain.</p></li>
<li><p>The interpretation of a unary predicate will be a <em>set</em> of individuals.</p>
<p>e.g., the interpretation of <em>run</em> is the set of individuals who run.</p></li>
<li><p>The interpretation of a binary predicate will be a binary relation between individuals, i.e., a set of ordered pairs.</p>
<p>e.g., the interpretation of <em>hugs</em> is the set of ordered pairs <span class="math inline">\(⟨x,y⟩\)</span>, such that <span class="math inline">\(x\)</span> hugs <span class="math inline">\(y\)</span>.</p></li>
</ul>
</section>
<section id="a-note-on-type-setting-conventions" class="level2">
<h2>A note on type-setting conventions</h2>
<ul>
<li><p>When we think though the meaning of the English NP “Homer”, we need to distinguish three levels:</p>
<ul>
<li><p>The object-language expression “Homer”, which will be set in the same typeface as my notes. This is an NP/DP in the natural language English.</p></li>
<li><p>The metalanguage expression <span class="math inline">\(\metalang{Homer}\)</span>, which is an individual constant in the vocabulary of our formal language – I’ll set metalanguage expressions in a serif typeface.</p></li>
<li><p>The person <span class="math inline">\(\entity{Homer}\)</span>, who is an entity in our domain. I’ll typeset entities in the domain in a fixed-width typeface.</p></li>
</ul></li>
<li><p>It’s important to be mindful of these distinctions as we move forwards…I’m not perfect, and I might typeset things incorrectly sometimes. It’s good practice for you to correct me if/when this happens!</p></li>
</ul>
</section>
<section id="semantics-iv" class="level2">
<h2>Semantics iv</h2>
<ul>
<li>task: Add some <em>ternary predicates</em> to L<sub>1</sub> (i.e., predicates that take three arguments).
<ul>
<li>what is the interpretation of a ternary predicate in <span class="math inline">\(M\)</span>?</li>
<li>what syntactic category does a ternary predicate correspond to, intuitively?</li>
</ul></li>
</ul>
</section>
<section id="semantics-of-l1-definition" class="level2">
<h2>Semantics of L<sub>1</sub> (definition)</h2>
<ul>
<li>If <span class="math inline">\(α\)</span> is a predicate or an individual constant, then:
<ul>
<li><span class="math inline">\(\evalM[M]{α} = I(α)\)</span>.</li>
</ul></li>
<li>If <span class="math inline">\(π\)</span> is a unary predicate and <span class="math inline">\(α\)</span> is a individual constant, then:
<ul>
<li><span class="math inline">\(\evalM[M]{ϕ(α)} = 1\text{ if }\evalM[M]{α} ∈ \evalM[M]{π}\)</span></li>
<li><span class="math inline">\(\evalM[M]{ϕ(α)} = 0\)</span> otherwise</li>
</ul></li>
<li><p>N.b. we’re gonna save ourselves some time in the future by writing <em>if and only if</em> (iff), to give truth and falsity conditions in one line. Since we’re assuming the excluded middle (every formula is either true or false), this is harmless.</p></li>
<li><p>Note that <span class="math inline">\(\evalM[M]{.}\)</span> is itself a <em>function</em> from any vocabulary item or formula <span class="math inline">\(α\)</span> of L<sub>1</sub> to the semantic value of <span class="math inline">\(α\)</span> in our model <span class="math inline">\(M\)</span>.</p></li>
</ul>
</section>
<section id="semantics-of-l1-continued" class="level2">
<h2>Semantics of L<sub>1</sub> continued</h2>
<ul>
<li>if <span class="math inline">\(π\)</span> is a binary predicate, and <span class="math inline">\(α\)</span> and <span class="math inline">\(β\)</span> are terms, then:
<ul>
<li><span class="math inline">\(\evalM[M]{π(α,β)} = 1 \mathrm{iff} ⟨\evalM[M]{α},\evalM[M]{β}⟩ ∈ \evalM[M]{π}\)</span></li>
</ul></li>
<li><p><span class="math inline">\(\evalM[M]{¬ϕ} = 1  \mathrm{iff} \evalM[M]{ϕ} = 0\)</span></p></li>
<li><span class="math inline">\(\evalM[M]{ϕ ∧ ψ} = 1 \mathrm{iff} \evalM[M]{ϕ} = 1 \mathrm{and} \evalM[M]{ψ} = 1\)</span></li>
<li><span class="math inline">\(\evalM[M]{ϕ ∨ ψ} = 1 \mathrm{iff} \evalM[M]{ϕ} = 1 \mathrm{or} \evalM[M]{ψ} = 1\)</span></li>
<li><span class="math inline">\(\evalM[M]{ϕ → ψ} = 1 \mathrm{unless} \evalM[M]{ϕ} = 1 \mathrm{and} \evalM[M]{ψ} = 0\)</span></li>
<li><p><span class="math inline">\(\evalM[M]{ϕ ↔ ψ} = 1 \mathrm{iff} \evalM[M]{ϕ} = \evalM[M]{ψ}\)</span></p></li>
</ul>
</section>
<section id="recursion" class="level2">
<h2>Recursion</h2>
<ul>
<li><p>Let’s look again at our rule for the semantic value of a conjunctive formula:</p></li>
<li><p><span class="math inline">\(\evalM[M]{ϕ ∧ ψ} = 1 \mathrm{iff} \evalM[M]{ϕ} = 1 \mathrm{and} \evalM[M]{ψ}\)</span></p></li>
<li><p><span class="math inline">\(\evalM{.}\)</span>…is a recursive function! In other words, it can recycle it’s own output as input.</p></li>
<li><p>If we have a recursive syntax, then we better have a recursive semantics.</p></li>
</ul>
</section>
<section id="recursive-semantics" class="level2">
<h2>Recursive semantics</h2>
<ul>
<li>Compute the truth-conditions of the following well-formed formula of L<sub>1</sub>.</li>
</ul>
<p><span class="math display">\[
(\metalang{happy}(\metalang{Jeff}) ∧ \metalang{happy}(\metalang{Troy})) ∧ \metalang{bored}(\metalang{Britta})
\]</span></p>
</section>
<section id="exercise" class="level2">
<h2>Exercise</h2>
<ul>
<li>Convert the following sentences of English into well-formed formulae of L<sub>1</sub>, and compute their truth-conditions.</li>
</ul>
<ol start="9" class="example" type="1">
<li><p>If Jeff is happy, then Britta and Annie are bored.</p></li>
<li><p>if Jeff is happy, then Britta is bored or Annie is bored.</p></li>
<li><p>Britta isn’t bored or happy.</p></li>
</ol>
<ul>
<li>Make a note of any interesting decision points in translating the sentences of English into formulae of L<sub>1</sub>.</li>
</ul>
</section>
<section id="english-as-a-formal-language" class="level2">
<h2>English as a formal language</h2>
<ul>
<li><p>have we made good on Montague’s conjecture?</p></li>
<li><p>Right now, we can only deal with proper names and verbs – we still have a long way to go.</p></li>
<li><p>AND as you may have noticed, the procedure for translating English into L<sub>1</sub> relies to a large extent on intuition.</p></li>
</ul>
</section>
<section id="the-syntax-semantics-interface" class="level2">
<h2>The syntax-semantics interface</h2>
<ol start="12" class="example" type="1">
<li>If Jeff is happy, then Britta is bored or Annie is bored.</li>
</ol>
<ul>
<li>There were two valid translations:</li>
</ul>
<ol start="13" class="example" type="1">
<li><p><span class="math inline">\(\metalang{happy}(J) → (\metalang{bored}(B) ∨ \metalang{bored}(A))\)</span></p></li>
<li><p><span class="math inline">\((\metalang{happy}(J) → \metalang{bored}(B)) ∨ \metalang{bored}(A)\)</span></p></li>
</ol>
<ul>
<li>Can our procedure for translating sentences of English into formulae ever be completely deterministic? What would help?</li>
</ul>
</section>
<section id="structural-ambiguity" class="level2">
<h2>Structural ambiguity</h2>

<ol start="15" class="example" type="1">
<li><span class="math inline">\(\metalang{happy}(J) → (\metalang{bored}(B) ∨ \metalang{bored}(A))\)</span></li>
</ol>
</section>
<section id="structural-ambiguity-ii" class="level2">
<h2>Structural ambiguity ii</h2>

<ol start="16" class="example" type="1">
<li><span class="math inline">\((\metalang{happy}(J) → \metalang{bored}(B)) ∨ \metalang{bored}(A)\)</span></li>
</ol>
</section>
<section id="compositional-semantics" class="level2">
<h2>Compositional semantics</h2>
<ul>
<li><p>What we want is a procedure for mapping each <em>terminal node</em> to an element of our <em>vocabulary</em>, and each <em>non-terminal node</em> to a well-formed formula.</p></li>
<li><p>This is the study of <em>syntax-semantics interface</em>, and encompasses a great deal of what formal semanticists do, especially in the generative tradition.</p></li>
<li><p>I won’t really be going into much depth about how this works in this class, but if you’re interested, the <em>locus classicus</em> is <span class="citation" data-cites="Heimb">@Heimb</span>, but see also <span class="citation" data-cites="jacobson_compositional_2014">@jacobson_compositional_2014</span> for an excellent contemporary introduction.</p></li>
</ul>
</section>
<section id="compositional-semantics-ii" class="level2">
<h2>Compositional semantics ii</h2>
<ul>
<li><p>Instead, we’re going to rely on our semantic intuitions for translating English into a formal language, and go from there.</p></li>
<li><p>All of the action will be in thinking through what <em>syntactic</em> properties our formal language should have, and moreover, specifying a semantics for the language which indirectly captures our intuitions about the truth-conditions of English sentences.</p></li>
</ul>
</section>
<section id="first-order-logic-fol" class="level2">
<h2>First Order Logic (FOL)</h2>
<ul>
<li>Consider the following sentences of English:</li>
</ul>
<ol start="17" class="example" type="1">
<li><p>Someone is happy.</p></li>
<li><p>It’s not the case that everyone is bored.</p></li>
<li><p>She is sitting down.</p></li>
</ol>
<ul>
<li>Rather than using proper names, we’re using <em>quantificational NPs</em> like <em>someone</em>, and <em>pronouns</em> like <em>she</em>.</li>
</ul>
</section>
<section id="syntax-of-fol" class="level2">
<h2>Syntax of FOL</h2>
<ul>
<li><p>Note that quantificational NPs and pronouns have the same distribution as proper names.</p></li>
<li><p>This makes it easy enough to add some extra resources to L<sub>1</sub>.</p></li>
</ul>
</section>
<section id="syntax-of-fol-ii" class="level2">
<h2>Syntax of FOL ii</h2>
<ul>
<li><p>For pronouns we’re going to add <em>variables</em>, for which we’ll use the letters <span class="math inline">\(x\)</span>, <span class="math inline">\(y\)</span>, <span class="math inline">\(z\)</span>, etc. We’ll refer to both <em>individual constants</em> like <span class="math inline">\(\metalang{Jeff}\)</span> and variables as <em>terms</em>.</p>
<p>Why not just add <em>he, she, they</em> etc., to our vocabulary as constants? We’ll see why when we get to the semantics.</p></li>
<li><p>We’re also going to add two new logical operators: <span class="math inline">\(∃\)</span>, and <span class="math inline">\(∀\)</span>, which correspond to <em>someone</em> and <em>everyone</em> (roughly).</p></li>
</ul>
</section>
<section id="syntax-of-fol-iii" class="level2">
<h2>Syntax of FOL iii</h2>
<ul>
<li>the first part of the syntax is just our syntax of L<sub>1</sub>, but with <em>individual constant</em> replaced by <em>term</em>. This means that variables can occupy the same environments as proper names.</li>
</ul>
<ol type="1">
<li><p>If <span class="math inline">\(π\)</span> is a unary predicate and <span class="math inline">\(α\)</span> is a , then <span class="math inline">\(π(α)\)</span> is a formula.</p></li>
<li><p>If <span class="math inline">\(π\)</span> is a binary predicate and α and β are , then <span class="math inline">\(π(α,β)\)</span> is a formula.</p></li>
<li><p>If <span class="math inline">\(ϕ\)</span> is a formula, then <span class="math inline">\(¬ϕ\)</span> is a formula.</p></li>
<li><p>If <span class="math inline">\(ϕ\)</span> and <span class="math inline">\(ψ\)</span> are formulas, then <span class="math inline">\([ϕ ∧ ψ]\)</span> is a formula.</p></li>
<li><p>If <span class="math inline">\(ϕ\)</span> and <span class="math inline">\(ψ\)</span> are formulas, then <span class="math inline">\([ϕ ∨ ψ]\)</span> is a formula.</p></li>
<li><p>If <span class="math inline">\(ϕ\)</span> and <span class="math inline">\(ψ\)</span> are formulas, then <span class="math inline">\([ϕ → ψ]\)</span> is a formula.</p></li>
<li><p>If <span class="math inline">\(ϕ\)</span> and ψ$ are formulas, then <span class="math inline">\([ϕ ↔ ψ]\)</span> is a formula.</p></li>
</ol>
</section>
<section id="syntax-of-fol-iv" class="level2">
<h2>Syntax of FOL iv</h2>
<ul>
<li>Quantificational operators are accompanied by variables:</li>
</ul>
<ol start="8" type="1">
<li><p>If <span class="math inline">\(u\)</span> is a variable and <span class="math inline">\(ϕ\)</span> is a formula, then <span class="math inline">\(∃uϕ\)</span> is a formula.</p></li>
<li><p>If <span class="math inline">\(u\)</span> is a variable and <span class="math inline">\(ϕ\)</span> is a formula, then <span class="math inline">\(∀uϕ\)</span> is a formula.</p></li>
</ol>
</section>
<section id="open-vs.closed-formulae" class="level2">
<h2>Open vs. closed formulae</h2>
<ul>
<li><p>A formula is <em>open</em> if it contains free variables, and <em>closed</em> otherwise.</p></li>
<li><p>Free variables are those that are not <em>bound</em>.</p></li>
<li><p>A variable is <em>bound</em> by the closest matching quantifier that takes scope over it.</p></li>
<li><p>Task: for each of the following formulae, is it open or closed:</p></li>
</ul>
<ol type="1">
<li><p><span class="math inline">\(∃ y[\metalang{likes}(x,y)]\)</span></p></li>
<li><p><span class="math inline">\(∀ x[\metalang{happy}(x)] ∧ \metalang{arrived}(x)\)</span></p></li>
<li><p><span class="math inline">\(∃ z[\metalang{hugs}(z)(z)]\)</span></p></li>
</ol>
</section>
<section id="towards-a-semantics-of-fol" class="level2">
<h2>Towards a semantics of FOL</h2>
<ul>
<li><p>Before we get into the formal nitty-gritty, I want you to think about the meaning of the following sentence. Is it possible to express in terms of <em>truth-conditions</em>?</p>
<ol start="20" class="example" type="1">
<li>She is Donald Trump’s wife.</li>
</ol></li>
<li><p>What factors does the interpretation of (20) depend on?</p></li>
</ul>
</section>
<section id="assignments" class="level2">
<h2>Assignments</h2>
<ul>
<li><p>Intuitively, whether or not (20) is true, depends on who the speaker intended to refer to with the pronoun <em>she</em>.</p></li>
<li><p>If the speaker intended to refer to Melania Trump, then (20) is true, and otherwise it is false.</p></li>
</ul>
</section>
<section id="assignments-ii" class="level2">
<h2>Assignments ii</h2>
<ul>
<li><p>We can use multiple occurrences of the same pronoun to refer to different individuals.</p>
<ol start="21" class="example" type="1">
<li>She is Donald Trump’s wife and <em>she</em> is Bill Clinton’s wife.</li>
</ol></li>
<li><p>For this reason, we have to relativize the truth of a sentence to who the speaker intended each <em>tokening</em> of a pronoun to refer to.</p></li>
<li><p>This is why we need something like variables in our formal language. We need a device for distinguishing between occurrences of pronouns.</p></li>
</ul>
</section>
<section id="assignments-iii" class="level2">
<h2>Assignments iii</h2>
<ul>
<li>As a notational convenience, we will write things like this:</li>
</ul>
<ol start="22" class="example" type="1">
<li>She<span class="math inline">\(_x\)</span> is Donald Trump’s wife, and she<span class="math inline">\(_y\)</span> is Bill Clinton’s wife.</li>
</ol>
<ul>
<li>This tells us that the first <em>she</em> corresponds to the variable <span class="math inline">\(x\)</span> in the logical translation, and the second <em>she</em> corresponds to the variable <span class="math inline">\(y\)</span>.</li>
</ul>
</section>
<section id="assignments-iv" class="level2">
<h2>Assignments iv</h2>
<ul>
<li>Ok, so the translation of <em>She<span class="math inline">\(ₓ\)</span> is Donald Trump’s wife</em> is the following:</li>
</ul>
<p><span class="math display">\[
\metalang{wife}(\metalang{Trump},x)
\]</span></p>
<ul>
<li><p>How do we capture the notion that the truth of this formula is relative to who the pronoun refers to?</p></li>
<li><p>We’re going to <em>relativise</em> truth, to a <em>context</em> <span class="math inline">\(g\)</span>. Formally, <span class="math inline">\(g\)</span> is a function from variables to objects, i.e., an <em>assignment function</em>.</p></li>
</ul>
</section>
<section id="assignments-v" class="level2">
<h2>Assignments v</h2>
<p><span class="math display">\[
g₁ = \left[\begin{aligned}[c]
    &amp;x &amp;↦ &amp;\entity{Melania}\\
    &amp;y &amp;↦ &amp;\entity{Hilary}\\
    &amp;...
    \end{aligned}\right]
\]</span></p>
<p><span class="math display">\[
g₂ = \left[\begin{aligned}[c]
    &amp;x &amp;↦ &amp;\entity{Hilary}\\
    &amp;y &amp;↦ &amp;\entity{Melania}\\
    &amp;...
    \end{aligned}\right]
\]</span></p>
</section>
<section id="assignments-vi" class="level2">
<h2>Assignments vi</h2>
<ul>
<li><span class="math inline">\(\metalang{wife}(\metalang{Trump},x)\)</span> is true relative to the assignment <span class="math inline">\(g₁\)</span> but false relative to the assignment <span class="math inline">\(g₂\)</span>.</li>
</ul>
</section>
<section id="assignments-vii" class="level2">
<h2>Assignments vii</h2>
<ul>
<li><p>From now on, interpretation isn’t just relative to a model <span class="math inline">\(M\)</span>, but also relative to an assignment <span class="math inline">\(g\)</span>.</p></li>
<li><p>Instead of <span class="math inline">\(\evalM[M]{ϕ}\)</span>, we write <span class="math inline">\(\evalM[M,g]{ϕ}\)</span>.</p></li>
<li><p>The interpretation of a variable <span class="math inline">\(x\)</span> is just whatever the assignment <span class="math inline">\(g\)</span> maps it to.</p></li>
<li><p><span class="math inline">\(\evalM[M,g]{x} = g(x)\)</span></p></li>
<li><p><span class="math inline">\(\evalM[M,g₁]{x} = \entity{Melania}\)</span>; <span class="math inline">\(\evalM[M,g₂]{x} = \entity{Hilary}\)</span></p></li>
</ul>
</section>
<section id="semantics-of-fol" class="level2">
<h2>Semantics of FOL</h2>
<ul>
<li><p>The most important new rule we’ll be dealing with is the following:</p></li>
<li><p>If <span class="math inline">\(α\)</span> is a variable, then <span class="math inline">\(\evalM[M,g]{α} = g(α)\)</span></p></li>
<li><p>Most of the rest of our semantic rules will be identical to those of L<sub>1</sub>, but with an additional parameter for the assignment <span class="math inline">\(g\)</span>.</p></li>
</ul>
</section>
<section id="semantics-of-fol-ii" class="level2">
<h2>Semantics of FOL ii</h2>
<ul>
<li>If <span class="math inline">\(α\)</span> is a predicate or an individual constant, then:
<ul>
<li><span class="math inline">\(\evalM[M,g]{α} = I(α)\)</span>.</li>
</ul></li>
<li>If <span class="math inline">\(π\)</span> is a unary predicate and <span class="math inline">\(α\)</span> is a individual constant, then:
<ul>
<li><span class="math inline">\(\evalM[M,g]{ϕ(α)} = 1\text{ iff }\evalM[M,g]{α} ∈ \evalM[M,g]{π}\)</span></li>
</ul></li>
<li>if <span class="math inline">\(π\)</span> is a binary predicate, and <span class="math inline">\(α\)</span> and <span class="math inline">\(β\)</span> are terms, then:
<ul>
<li><span class="math inline">\(\evalM[M,g]{π(α,β)} = 1 \metalang{iff} ⟨\evalM[M,g]{α},\evalM[M,g]{β}⟩ ∈ \evalM[M,g]{π}\)</span></li>
</ul></li>
</ul>
</section>
<section id="semantics-of-fol-iii" class="level2">
<h2>Semantics of FOL iii</h2>
<ul>
<li><p><span class="math inline">\(\evalM[M,g]{¬ϕ} = 1  \metalang{iff} \evalM[M,g]{ϕ} = 0\)</span></p></li>
<li><span class="math inline">\(\evalM[M,g]{ϕ ∧ ψ} = 1 \metalang{iff} \evalM[M,g]{ϕ} = 1 \metalang{and} \evalM[M,g]{ψ} = 1\)</span></li>
<li><span class="math inline">\(\evalM[M,g]{ϕ ∨ ψ} = 1 \metalang{iff} \evalM[M,g]{ϕ} = 1 \metalang{or} \evalM[M,g]{ψ} = 1\)</span></li>
<li><span class="math inline">\(\evalM[M,g]{ϕ → ψ} = 1 \metalang{unless} \evalM[M,g]{ϕ} = 1 \metalang{and} \evalM[M,g]{ψ} = 0\)</span></li>
<li><p><span class="math inline">\(\evalM[M,g]{ϕ ↔ ψ} = 1 \metalang{iff} \evalM[M,g]{ϕ} = \evalM[M,g]{ψ}\)</span></p></li>
</ul>
</section>
<section id="pronouns" class="level2">
<h2>Pronouns</h2>
<ul>
<li><p>We now have all of the resources we need for translating a subset of sentences of English with pronouns into FOL, and assigning them truth-conditions. Do this for the following sentence:</p>
<ol start="23" class="example" type="1">
<li>She arrived and she sat down.</li>
</ol></li>
<li>Make a note of the decisions you have to make when you translate (23) into FOL.
<ul>
<li>What do you notice?</li>
<li>How does it affect the truth conditions.</li>
</ul></li>
</ul>
</section>
<section id="pronouns-ii" class="level2">
<h2>Pronouns ii</h2>
<ul>
<li>There are two candidate translations (Logical Forms) for (23):</li>
</ul>
<ol start="24" class="example" type="1">
<li><p><span class="math inline">\(\metalang{arrived}(x) ∧ \metalang{satDown}(x)\)</span></p></li>
<li><p><span class="math inline">\(\metalang{arrived}(x) ∧ \metalang{satDown}(y)\)</span></p></li>
</ol>
</section>
<section id="co-indexation" class="level2">
<h2>Co-indexation</h2>
<p><span class="math display">\[\begin{aligned}[t]
\evalM[M,g]{\metalang{arrived}(x) ∧ \metalang{satDown}(x)} = 1\metalang{ iff }\\
g(x) ∈ I(\metalang{arrived})\text{ and }g(x) ∈ I(\metalang{satDown})
\end{aligned}\]</span></p>
<ul>
<li>Since an <em>assignment function</em> is a <em>function</em>, when we map two pronouns to the same variable, they are <em>guaranteed</em> to pick out the same individual relative to any assignment.</li>
</ul>
</section>
<section id="contra-indexation" class="level2">
<h2>Contra-indexation</h2>
<p><span class="math display">\[\begin{aligned}[t]
\evalM[M,g]{\metalang{arrived}(x) ∧ \metalang{satDown}(y)} = 1\metalang{ iff }\\
g(x) ∈ I(\metalang{arrived})\text{ and }g(y) ∈ I(\metalang{satDown})
\end{aligned}\]</span></p>
<ul>
<li>when we map two pronouns to distinct variables, is it <em>guaranteed</em> that they pick out distinct variables, relative to any assignment?</li>
</ul>
</section>
<section id="contra-indexation-ii" class="level2">
<h2>Contra-indexation ii</h2>
<ul>
<li><p>no.</p></li>
<li><p>Consider the assignment <span class="math inline">\(g_c = \left[\begin{aligned}[c] &amp;x &amp;↦ &amp;\entity{Hilary}\\ &amp;y &amp;↦ &amp;\entity{Hilary}\\  \end{aligned}\right]\)</span></p></li>
</ul>
<p><span class="math display">\[\begin{aligned}[t]
\evalM[M,g_c]{\metalang{arrived}(x) ∧ \metalang{satDown}(y)} = 1\metalang{ iff }\\
\entity{Hilary} ∈ I(\metalang{arrived})\text{ and }\entity{Hilary} ∈ I(\metalang{satDown})
\end{aligned}\]</span></p>
</section>
<section id="contra-indexation-iii" class="level2">
<h2>Contra-indexation iii</h2>
<ul>
<li><p>but, if we map two pronouns to distinct variables, we make it <em>possible</em> for them to pick out distinct individuals. Consider the following assignment:</p>
<p><span class="math display">\[g_d = \left[\begin{aligned}[c]
 &amp;x &amp;↦ &amp;\entity{Hilary}\\
 &amp;y &amp;↦ &amp;\entity{Melania}\\
 \end{aligned}\right]\]</span></p></li>
</ul>
<p><span class="math display">\[\begin{aligned}[t]
\evalM[M,g_d]{\metalang{arrived}(x) ∧ \metalang{satDown}(y)} = 1\metalang{ iff }\\
\entity{Hilary} ∈ I(\metalang{arrived})\text{ and }\entity{Melania} ∈ I(\metalang{satDown})
\end{aligned}\]</span></p>
</section>
<section id="assignments-and-contexts" class="level2">
<h2>Assignments and contexts</h2>
<ul>
<li><p>We can think of an assignment <span class="math inline">\(g\)</span> as formalising aspects of the <em>context of utterance</em>.</p></li>
<li><p><span class="math inline">\(g_c\)</span> represents a context in which both “she<span class="math inline">\(ₓ\)</span>” and “she<span class="math inline">\(_y\)</span>” are intended to pick out <span class="math inline">\(\entity{Hilary}\)</span>.</p></li>
<li><p><span class="math inline">\(g_d\)</span> represents a context in which “she<span class="math inline">\(ₓ\)</span>” is intended to pick out <span class="math inline">\(\entity{Hilary}\)</span>, and “she<span class="math inline">\(_y\)</span>” is intended to pick out <span class="math inline">\(\entity{Melania}\)</span>.</p></li>
</ul>
</section>
<section id="assignments-and-the-global-environment" class="level2">
<h2>Assignments and the global environment</h2>
<ul>
<li><p>Computer programs often need access to a <em>global environment</em>.</p></li>
<li><p>For example, imagine a program that pull’s a user’s first name and surname from a database, and concatenates them.</p></li>
<li><p>The <em>meaning</em> of this program can be thought of as assignment sensitive:</p></li>
</ul>
<pre><code>query g  
println (g(firstName) ++ g(surname))</code></pre>
<ul>
<li><span class="math inline">\(g\)</span> here is an assignment function, standing in for an entry in a database specifying an individuals first name and surname.</li>
</ul>
</section>
<section id="assignments-and-the-global-environment-ii" class="level2">
<h2>Assignments and the global environment ii</h2>
<ul>
<li><p>The formal tools computer programmers use for thinking about the role the global environment plays look <em>extremely</em> similar to the tools we’re using to analyse the <em>context</em>.</p></li>
<li><p>If you have some background in programming, take a look at the <em>Reader</em> monad in functional languages like <em>Haskell</em>.</p></li>
<li><p>If not don’t worry - hopefully the basic idea is intuitive enough.</p></li>
</ul>
</section>
<section id="back-to-quantificational-nps" class="level2">
<h2>Back to quantificational NPs</h2>
<ul>
<li><p>we still haven’t said anything about the meaning of sentences like the following:</p>
<ol start="26" class="example" type="1">
<li><p>Someone arrived.</p></li>
<li><p>Everyone arrived.</p></li>
</ol></li>
<li><p>It turns out that <em>assignments</em> provide us with the machinery to analyse these cases too.</p></li>
</ul>
</section>
<section id="the-informal-idea" class="level2">
<h2>The informal idea</h2>
<ol start="28" class="example" type="1">
<li><p>Someone arrived.</p></li>
<li><p><span class="math inline">\(\evalM[M,g]{∃ x[\metalang{arrived}(x)]}\)</span></p></li>
</ol>
<ul>
<li><p>When is (29) true relative to an assignment <span class="math inline">\(g\)</span>?</p></li>
<li><p>Intuitively, it’s truth is <em>assignment-invariant</em> – that is to say that it doesn’t depend on what the context of utterance is.</p></li>
<li><p>It’s true just in case we can find <em>any</em> assignment <span class="math inline">\(g'\)</span>, which is identical to <span class="math inline">\(g\)</span> except for what it assigns <span class="math inline">\(x\)</span> to, which makes (29) true.</p></li>
</ul>
</section>
<section id="illustration" class="level2">
<h2>Illustration</h2>
<ol start="30" class="example" type="1">
<li><p><span class="math inline">\(\entity{arrive} = \Set{\entity{Melania}}\)</span></p></li>
<li><p><span class="math inline">\(g = \left[\begin{aligned}[c] &amp;x &amp;↦ &amp;\entity{Hilary}\\ &amp;y &amp;↦ &amp;\entity{Melania} \end{aligned}\right]\)</span></p></li>
</ol>
<ul>
<li><p>the truth of <span class="math inline">\(\evalM[M,g]{∃ x[\metalang{arrived}(x)]}\)</span> doesn’t depend on what <span class="math inline">\(g\)</span> maps <span class="math inline">\(x\)</span> to, but rather if we can find a <span class="math inline">\(g'\)</span> that maps <span class="math inline">\(x\)</span> to someone that arrived.</p></li>
<li><p>We can find such a <span class="math inline">\(g'\)</span>: <span class="math inline">\(\left[\begin{aligned}[c] &amp;x &amp;↦ &amp;\entity{Melania}\\ &amp;y &amp;↦ &amp;\entity{Melania} \end{aligned}\right]\)</span></p></li>
</ul>
</section>
<section id="formalism" class="level2">
<h2>Formalism</h2>
<ul>
<li><p>We can state the rule for quantificational sentences more formally like so;</p></li>
<li><p><span class="math inline">\(\evalM[M,g]{∃ v ϕ} = 1\)</span> iff there is at least one <span class="math inline">\(g'\)</span> s.t. <span class="math inline">\(g'[v]g\)</span> and <span class="math inline">\(\evalM[M,g']{ϕ} = 1\)</span></p></li>
<li><p><span class="math inline">\(\evalM[M,g]{∀ v ϕ} = 1\)</span> iff for every <span class="math inline">\(g'\)</span> s.t. <span class="math inline">\(g'[v]g\)</span>, <span class="math inline">\(\evalM[M,g']{ϕ} = 1\)</span></p></li>
</ul>
</section>
<section id="minimally-differing-assignments" class="level2">
<h2>Minimally differing assignments</h2>
<ul>
<li>Why do we look at only <em>minimally</em> differing assignments?</li>
</ul>
<ol start="32" class="example" type="1">
<li><span class="math inline">\(∃ x[\metalang{arrive}(x) ∧ \metalang{satDown}(y)]\)</span></li>
</ol>
<ul>
<li><p>Let’s say that we’re in a context with the following <span class="math inline">\(g\)</span>: <span class="math inline">\(\left[\begin{aligned}[c] &amp;x &amp;↦ &amp;\entity{Melania}\\ &amp;y &amp;↦ &amp;\entity{Hilary} \end{aligned}\right]\)</span></p></li>
<li><p>And let’s say that it’s true that Hilary arrived but only Melania sat down.</p></li>
</ul>
</section>
<section id="minimally-differing-assignments-ii" class="level2">
<h2>Minimally differing assignments ii</h2>
<ul>
<li><p>Well, if we’re allowed to look at assignments that differ in more than just what <span class="math inline">\(x\)</span> gets mapped to, then we <em>can</em> find an assignment <span class="math inline">\(g'\)</span> which makes the formula true.</p>
<p><span class="math display">\[
g' = \left[\begin{aligned}[c]
&amp;x &amp;↦ &amp;\entity{Hilary}\\
&amp;y &amp;↦ &amp;\entity{Melania}
\end{aligned}\right]
\]</span></p></li>
<li><p>This is clearly a bad prediction though – the truth of the previous formula should depend on who <span class="math inline">\(y\)</span> picks out in the context of utterance.</p></li>
</ul>
</section>
<section id="non-determinism" class="level2">
<h2>Non-determinism</h2>
<ul>
<li><p>We can think of existential quantifiers as triggering a <em>non-deterministic computation</em>. When considering the truth of <span class="math inline">\(∃x[\metalang{arrive}(x)]\)</span>, we compute the truth of statements of the form <span class="math inline">\(α ∈ I(\metalang{arrive})\)</span>, where <span class="math inline">\(α\)</span> is some object.</p></li>
<li><p>As soon as we find one that is true, we travel back to a deterministic world, by stating that the formula is true.</p></li>
</ul>
</section>
<section id="non-determinism-ii" class="level2">
<h2>Non-determinism ii</h2>
<ul>
<li><p>This is going to be important once we start looking at dynamic semantics.</p></li>
<li><p>For now it is important to remember that this is just a metaphor to help you think about what existential quantification is doing. See Simon Charlow’s dissertation for some (very advanced) reading on the connections between existential quantification and non-determinism.</p></li>
</ul>
</section>
<section id="binding" class="level2">
<h2>Binding</h2>
<ul>
<li><p>The fact that quantificational operators manipulate the assignment function can be used to analyse the fact that quantifiers can <em>bind</em> pronouns, reflexives, and other anaphora in natural language.</p>
<ol start="33" class="example" type="1">
<li><p>Someone<span class="math inline">\(^x\)</span> likes themselves<span class="math inline">\(ₓ\)</span>.</p></li>
<li><p><span class="math inline">\(∃ \alert{x}[\metalang{likes}(x,\alert{x})]\)</span></p></li>
</ol></li>
<li><p>Binding obtains just in case the variable introduced by the quantificational operator matches the variable introduced by the pronoun.</p></li>
</ul>
</section>
<section id="interpreting-binding" class="level2">
<h2>Interpreting binding</h2>
<ul>
<li><span class="math inline">\(\evalM[M,g]{∃ x[\metalang{likes}(x,x)]} = 1\)</span> iff…</li>
<li><span class="math inline">\(∃ g'[g[x]g'\)</span> and <span class="math inline">\(\evalM[M,g']{\metalang{likes}(x,x)} = 1\)</span></li>
<li><p><span class="math inline">\(∃ g'[g[x]g'\)</span> and <span class="math inline">\(⟨g'(x),g'(x)⟩ ∈ I(\metalang{likes})\)</span></p></li>
<li><p>This is true, if we’re in a model, e.g., where..</p></li>
</ul>
<p><span class="math display">\[
I(\metalang{likes}) = \Set{⟨\metalang{Melania},\metalang{Melania}